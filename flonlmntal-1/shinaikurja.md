---
description: 関数と適用を評価します。
---

# （再帰しない）関数、クロージャ

さて、待ちに待った「関数」だ。長い道のりだったが、ようやくこれで「関数型言語」を実装したと言えることになる（かもね）。

詳細は省くが、「静的スコープ」は「関数」が適用時に自身が定義された場所での「環境」をもとに評価されていくことで実現できる。ここで、「関数」と「環境」をまとめたものを「クロージャ」という。でも面倒なので「クロージャ」も「関数」と言ってしまうかも。

## 関数の評価

「関数」は`R = fun(Var, Body)`のように表現することにする。「関数」を評価すると「クロージャ」を「値」として返す。

```text
eval_fun @@
 R = eval(fun(Var, Body), Env) :- 
 string(Var) |
 R = val(fun(Var, Body, Env)). 
```

評価後の「クロージャ」が`closure`じゃなくて`fun`になっているのはその方が短く書けるから（深い意味はない）。

## カリー化

#### カリー <a id="content_1_16"></a>

基本的に関数型言語は「カリー化」によって多変数っぽい関数が書ける（タプルを使って「本物の」多変数関数も書けるがここではやらない）。なので1変数関数だけ用意しておけば問題ない。が、実際に記述することを考えると面倒なので、これも糖衣構文ということで`R = fun([Var1, Var2, ...], Body)`を用意しよう。これをカリー化してやるルールは以下のようになる。

```text
 R = fun([Var|T],  Body) :- 
 R = fun(Var, fun(T, Body)).
 
 R = fun([],  Body) :- 
 R = Body. 
```

あと、ML系だと`let f x … =` は`let f = fun x … ->` の糖衣構文であるからこいつも追加してしまおう。

```text
 R = let(FN, FV, FB, Body) :- 
 R = let(FN, fun(FV, FB), Body).
```



## 適用の評価

「関数（本当はクロージャ）」に「適用したい値」を適用したい。これは「関数」と「適用したい値」の2つの「値」をとる二項演算とも定義できる。これを`R = binop(app, Fun, Val)`のように表現することにする。

```text
app_fun @@
 R = fireable(app, val(fun(Var, Body, Env)), val(Val)) :- 
 R = eval(Body, [let(Var, Val), Env])). 
```

またも糖衣構文を用意した。

```text
 R = app(X, Y) :- R = binop(app, X, Y).
```

これでもないよりかはマシだろう。

